#!/usr/bin/env python
"""HethIO server for monitoring a agent traffic and recording for website.

"""

import os
import logging
import logging.handlers
import argparse
import sys
import time  # this is only being used as part of the example
from ConfigParser import SafeConfigParser # read in config file
import subprocess # for executing other command line programs
import shlex # for spliting strings
from datetime import datetime
import string


try:
	from Queue import Queue, Empty
except ImportError:
	from queue import Queue, Empty  # python 3.x


ON_POSIX = 'posix' in sys.builtin_module_names


# Deafults
global CONF_FILENAME, LOG_FILEPATH, LOG_LEVEL
LOG_LEVEL = logging.INFO  # Could be e.g. "DEBUG" or "WARNING"


#MQTT Variables
global __PUBLISH, __SUBSCRIBE, __USERNAME, __BROKER
CONF_FILENAME = "/etc/hethio/server.conf"
LOG_FILEPATH = "/var/log/hethio"
__PUBLISH = "/usr/bin/mosquitto_pub"
__SUBSCRIBE = "/usr/bin/mosquitto_sub"

__BROKER = "heth.io"
__USERNAME = "hethio"


# Define and parse command line arguments
parser = argparse.ArgumentParser(description="HethIO - Systems Management Service")
parser.add_argument("-c", "--conf", help="configuration file to read from (default '" + CONF_FILENAME + "')")
parser.add_argument("-l", "--log", help="file to write log to (default '" + LOG_FILEPATH + "')")
#parser.add_argument('--speedtest', action="store_true", default=False)

# If the log file is specified on the command line then override the default
args = parser.parse_args()
if args.conf:
	CONF_FILENAME = args.conf

if args.log:
	LOG_FILEPATH = args.log


#=======================================================================================================================
# GENERIC FUNCTIONALITY
def touch(fname):
	if os.path.exists(fname):
		os.utime(fname, None)
	else:
		open(fname, 'a').close()

def deduplicate(seq):
	seen = set()
	seen_add = seen.add
	return [ x for x in seq if not (x in seen or seen_add(x))]



#=======================================================================================================================
# CONFIG

#user defined configuration variables
global __minute, __hour, TIMESTAMP, USERS
TIMESTAMP = datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')
USERS = ""
__minute = 0
__hour = 0

def read_config():
	global CONF_FILENAME,LOG_LEVEL,LOG_FILEPATH,__BROKER,__USERNAME
	# Read in configuration file
	configParser = SafeConfigParser()   
	try:
		configParser.read(CONF_FILENAME)

		# Read global section from config file
		if configParser.has_section('Global'):
			if configParser.has_option('Global','LogLevel'):
				LOG_LEVEL = configParser.get('Global','LogLevel')
			if configParser.has_option('Global','LogPath'):
				LOG_FILEPATH = configParser.get('Global','LogPath')


		# Read overrides to broker defaults from config file
		if configParser.has_section('Broker'):
			if configParser.has_option('Broker','broker'):
				__BROKER = configParser.get('Broker','broker')
			if configParser.has_option('Broker','username'):
				__USERNAME = configParser.get('Broker','username')

	except IOError:
		print "Unable to open " + CONF_FILENAME


	#create logging path if it doesn't exist
	if not os.path.exists(LOG_FILEPATH):
		os.makedirs(LOG_FILEPATH)

read_config()



#=======================================================================================================================
# LOGGER
global logger

# Configure logging to log to a file, making a new file at midnight and keeping the last 3 day's data
# Give the logger a unique name (good practice)
logger = logging.getLogger(__name__)
# Set the log level to LOG_LEVEL
logger.setLevel(LOG_LEVEL)

# Make a handler that writes to a file, making a new file at midnight and keeping 3 backups
try :
	handler = logging.handlers.TimedRotatingFileHandler(LOG_FILEPATH + "/server.log", when="midnight", backupCount=3)
except IOError:
	touch(LOG_FILEPATH + "/server.log")
# Format each log message like this
formatter = logging.Formatter('%(asctime)s %(levelname)-8s %(message)s')
# Attach the formatter to the handler
handler.setFormatter(formatter)
# Attach the handler to the logger
logger.addHandler(handler)

# Make a class we can use to capture stdout and sterr in the log
class MyLogger(object):
	def __init__(self, logger, level):
		"""Needs a logger and a logger level."""
		self.logger = logger
		self.level = level

	def write(self, message):
		"""Only log if there is a message (not just a new line)"""
		if message.rstrip() != "":
			self.logger.log(self.level, message.rstrip())

	def flush(self):
		pass

# Replace stdout with logging to file at INFO level
sys.stdout = MyLogger(logger, logging.INFO)
# Replace stderr with logging to file at ERROR level
sys.stderr = MyLogger(logger, logging.ERROR)







#=======================================================================================================================
# FUNCTIONALITY

def publish(topic, msg):
	"""Publish specified msg to specified topic using mosquitto tools"""
	global __BROKER, __USERNAME, logger, __PUBLISH, os
	if os.path.isfile(__PUBLISH):
		command_line = __PUBLISH + " -t '/" + __USERNAME + topic + "' -m '" + msg + "' -h '" + __BROKER + "' -u '" + __USERNAME + "'"
		logger.info(command_line)
		args = shlex.split(command_line)
		p1 = subprocess.Popen(args, stdout=subprocess.PIPE)
		output = p1.communicate()[0]
		return output
	else:
		logger.warning("Missing Publishing Utility (" + __PUBLISH + ")")
		return "Unable to publish message."




#=======================================================================================================================


# THIS FUNCTION IS EXECUTED EVERY MINUTE
def every_minute():
	global logger,__minute
	logger.info("Minute Elapsed")
	#logger.info("The counter is now " + str(i))
	#print "This is a print"
	
	read_config() #reload config every minute

	

	__minute = __minute + 1
	return;

# THIS FUNCTION IS EXECUTED EVERY HOUR
def every_hour():
	global logger,__minute, __hour, __SPENABLED
	if __minute >= 60: # EVERY HOUR
		logger.info("Hour Elapsed")

		# do nothing for now

		__minute = 0
		__hour = __hour + 1
	return;

# THIS FUNCTION IS EXECUTED EVERY HOUR
def every_day():
	global logger,__hour
	if __hour >= 24: # EVERY HOUR
		logger.info("Hour Elapsed")

		#do something every 24 hours

		__hour = 0
	return;




#=======================================================================================================================
# MAIN DAEMON LOOP

def main():
	global logger,TIMESTAMP
			
	oldepoch = int(time.time()) - 3600
	# Loop forever, doing something useful hopefully:
	while True:
		epoch = int(time.time()) #get current unix timestamp
		TIMESTAMP = datetime.fromtimestamp(time.time()).strftime('%Y-%m-%d %H:%M:%S')

		if epoch - oldepoch >= 60: # EVERY MINUTE
			every_hour()
			every_minute()
			every_day()

		oldepoch = epoch
		time.sleep(60)
		



if __name__ == '__main__':
	main()